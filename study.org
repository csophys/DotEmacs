* 编程语言
** 编程语言 c语言中的指针类型所占空间与采用什么类型无关，只和PU的寻址范围有关，即CPU的位数
 
 [[file:c:/EmacsDir/C/test.c::printf%20("x's%20size%20is%20%25d\n",sizeof(x))%3B][file:c:/EmacsDir/C/test.c::printf ("x's size is %d\n",sizeof(x));]]
** 编程语言 Java中涉及byte、short和char类型的运算操作首先会把这些值转换为int类型
  Java中涉及byte、short和char类型的运算操作首先会把这些值转换为int类型，然后对int类型值进行运算，最后得到int类型的结果。因此，如果把两个byte类型值相加，最后会得到一个int类型的结果。如果需要得到byte类型结果，必须将这个int类型的结果显式转换为byte类型。
  而至于为什么 s += 1 没有错，是因为Java的设计者当初对它做了特殊处理！
** 编程语言 Math中floor,round,ceil方法分析
- floor 返回不大于的最大整数 
- round 则是4舍5入的计算，入的时候是到大于它的整数（当-1.5时可见，四舍五入后得到的结果不是我们期待的，解决办法是先对他取绝对值，然后在用round方法）round方法，它表示“四舍五入”，算法为Math.floor(x+0.5)，即将原来的数字加上0.5后再向下取整，所以，Math.round(11.5)的结果为12，Math.round(-11.5)的结果为-11。
- ceil 则是不小于他的最小整数
 
 [[file:c:/task/task.org::*linux32%20symfoware%20V11(193.168.238.155)][linux32 symfoware V11(193.168.238.155)]]
** 编程语言 HashMap和HashTable的区别
1. Hashtable是Dictionary的子类，HashMap是Map接口的一个实现类；
2. Hashtable中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。即是说，在多线程应用程序中，不用专门的操作就安全地可以使用Hashtable了；而对于HashMap，则需要额外的同步机制。但HashMap的同步问题可通过Collections的一个静态方法得到解决：
Map Collections.synchronizedMap(Map m)
这个方法返回一个同步的Map，这个Map封装了底层的HashMap的所有方法，使得底层的HashMap即使是在多线程的环境中也是安全的。
3. 在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键，而应该用containsKey()方法来判断。
4. 其底层的实现机制不同，hashmap的访问速度要快于hashtable，因为它不需要进行同步检验，建议在非多线程环境中使用hashmap代替hashtable .

 
 [[file:c:/task/task.org::*linux32%20symfoware%20V11(193.168.238.155)][linux32 symfoware V11(193.168.238.155)]]
** 编程语言 java 中间变量缓存机制
　　public class Test2 { 
　　　　public static void main(String[] args) { 
　　　　　　int j = 0; 
　　　　　　for (int i = 0; i < 100; i++) { 
　　　　　　　　j = j++; 
　　　　　　} 
　　　　　　System.out.println(j); 
　　　　} 
　　} 

是0 
因为java用了中间缓存变量的机制 
j=j++;可换成如下写法。 
temp=j; //j++结果
j=j+1; //左侧计算完成后自加
j=temp; //赋值
所以结果为0 
 
 [[file://193.168.251.37/ct_set/common/common.xml::<macrodef%20name%3D"run-javaee-test">][file://193.168.251.37/ct_set/common/common.xml::<macrodef name="run-javaee-test">]]
** 编程语言 length和length()的区别
  - length是数组的属性，用来求数组的长度。
  - length是字符串的方法，用来求字符串的长度。
 
 [[file://193.168.251.37/ct_set/common/common.xml::<!--%20includes%3D"@{component}/@{pkgname}/@{mname}/@{testname}Test.class"%20-->][file://193.168.251.37/ct_set/common/common.xml::<!-- includes="@{component}/@{pkgname}/@{mname}/@{testname}Test.class" -->]]

*
* 设计模式
** 创建型模式：负责对象地创建
- 工厂模式：客户类和工厂类分开。消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。
- 建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。
- 工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。
- 原始模型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。
- 单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的“单一实例”的需求时才可使用。
** 结构性模式：处理类与对象间的组合
- 适配器（变压器）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。
- 桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合/聚合关系而不是继承关系，从而使两者可以独立的变化。
- 合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。
- 装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。
- 门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。
- 享元模式：FLYWEIGHT在拳击比赛中指最轻量级。享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。
- 代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。
** 行为型模式：类与对象交互中的职责分配
- 责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。
- 命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。
- 解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。
- 迭代子模式：迭代子模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。迭代子模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化
- 调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。
- 备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。
- 观察者模式：观察者模式定义了一种一队多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。
- 状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。
- 策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模式把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。
- 模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。
- 访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。

* 基本概念
** 基本概念 指针和引用的区别
    1) 引用必须被初始化，指针不必。
    2) 引用初始化以后不能被改变，指针可以改变所指的对象。
    3) 不存在指向空值的引用，但是存在指向空值的指针。
 
 [[file:~/.emacs.d/csophys/csophys_writingStyle.el::))]]
** 基本概念 进程和线程的基本概念
进程是在操作系统中能独立存在的基本单位，线程不能够独立存在，是存在与进程之中的。线程是执行任务的基本单位。线程可以由自己的专有寄存器(栈指针、程序计数器等)。但是代码区是共享的，不同的线程可以执行相同的函数。
线程的缺点如下：
- 线程也是程序，所以线程需要占用内存，线程越多，占用内存也越多

- 多线程需要协调和管理，所以需要CPU花时间跟踪线程

- 线程之间对共享资源的访问会相互影响，必须解决竞用共享资源的问题

- 线程太多会导致控制太复杂，最终可能造成很多BUG，一个线程的瘫痪很容易导致整个进程的崩溃
 
 [[file:c:/EmacsDir/Test.java]]
** 基本概念 graphviz 间距
  circo一般用于需要散开的情况。
  dot中可以用rankdir来决定布局，nodesep来决定node间距，ranksep来决定左右间距
 [[file:c:/EmacsDir/GitDocument/MyDocument/why.dot::rankdir%3DLR%3B][file:c:/EmacsDir/GitDocument/MyDocument/why.dot::rankdir=LR;]]
* 算法
** 算法 判断一个数是否是2的阶次方数
- 基本算法：设计一个递归函数，判断是否是1，返回true.不是，是否是偶数，是就整除2，继续调用当前函数。不然就返回false.
- 更优算法：当前整数如果是2的阶次方数，那么其的二进制形式一般式10000...形式，其数减去1再与本身相与应为0.故求a&(a-1)是否为0即可。
** 算法 字符串的排列和组合算法研究
 
 [[file:c:/EmacsDir/test.java::import%20java.util.*%3B][file:c:/EmacsDir/test.java::import java.util.*;]]
** 算法 常见的排序算法
- 排序算法总结
| 排序算法   | 稳定性 | 时间复杂度                          | 空间复杂度 |
|------------+--------+-------------------------------------+------------|
| 冒泡排序   | 稳定   | 最差，平均都是O(n2),最好是O(n)      |          1 |
| 双向冒泡   | 稳定   | 最差，平均都是O(n2),最好是O(n)      |          1 |
| 插入排序   | 稳定   | 最差，平均都是O(n2),最好是O(n)      |          1 |
| 归并排序   | 稳定   | 最差，最好都是O(nlogn)              |       O(n) |
| 基数排序   | 稳定   | O(dn)(d是常数)                      |       O(n) |
| 二叉树排序 | 稳定   | O(nlogn)                            |       O(n) |
| 选择排序   | 不稳定 | 最差，平均都是O(n2)                 |          1 |
| 希尔排序   | 不稳定 | O(nlogn)                            |          1 |
| 堆排序     | 不稳定 | 最差,平均情况和最好情况都是O(nlogn) |          1 |
| 快速排序   | 不稳定 | 平均是O(nlogn),最坏情况下是O(n2)    |   O(nlogn) |
注：
涉及到远距离交换的排序算法都是不稳定的。会打乱原有相同数字的相对顺序。
快速排序因为使用分治法的思想，需要用到函数栈来保存中间结果，所有复杂度为O(nlogn)

** 算法 统计同一个字符串出现次数
** 算法 筛法求素数
 
 [[file:~/study.org::*%E7%AE%97%E6%B3%95][算法]]
** 算法 求整数数组中最大和的子串
 
 [[file:~/study.org::*%E7%AE%97%E6%B3%95%20%E7%AD%9B%E6%B3%95%E6%B1%82%E7%B4%A0%E6%95%B0][算法 筛法求素数]]
** 算法 用10只狗测定1000瓶中哪瓶有毒
  - 按10进制方式给狗编号分别是1~10
  - 按2进制方法给药水编号。按照药水的第几位是1给相应的狗服药。
  最后对应的狗死掉的那个二进制数即为毒药
** 算法 如果F(n)=50!*5^n,请问n最少是多少是，F(n)和F(n+1)才拥有相同多的0作为位数
  如果向要得到相同数量的位数0,必须要算清楚由多少个2*5的10.1~50的阶乘总共由25+12+6+3+1=47个2的因子，10+2=12个5的因子，多处47-12=35个2的因子，所以必须配套35个5来得出10.
** 算法 公司有1000个苹果和10个箱子，实现将1000个苹果分别装入10个箱子，问：怎样做才能在客户无论需要多少苹果是，都可以整箱整箱地提供给客户
  答案：1,2,4,8,16,32,64,128,256,489。道理很简单，第N只箱子应该装的数量是前面1~N-1只箱子庄的数量的总和加1
